---
title: "adegenet tutorial"
author: "Vita"
date: "April 30, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(data.table)
library(dplyr)
library(adegenet)
library(hierfstat)

```


```{r}
input <- "../input/"
output <- "../output/"
pic_path <- "../graphs/"
```

## importing data

**for standart formats: **
* read.genetix, read.structure, read.fstat, and read.genepop
* import2genind (for authomatic file format detection)

```{r}
## creating GENIND object from .gtx file
obj <- read.genetix(system.file("files/nancycats.gtx",package = "adegenet"))
## rows are individuals (in this case 237); 
## columns are specific alleles: fca8 -- the loci, 135 -- specific allele, so that makes column: fca8.135. 
## Values are the genotype of that specific allele 
## slot @type can have values: codom -- for codominant markers, and PA --for presence/absence data.


## creating GENPOP object from genind object (stores pop)
## basicly the same as genind, but is reduced to the number of populationsXloci, instead of individualsXloci
catpop <- genind2genpop(obj)
catpop$tab[1:10, 1:10]
## rows are populations (in this case 17); 
## columns are specific alleles: fca8.135. 
## Values are the count of that specific allele in population

```

**non standart formats:**
1) rows -- ind, columns -- locus. Import as data.frame and convert to geneind obj: df2genind

```{r}
## generating data 
temp <- lapply(1:30, function(i) sample(1:9, 4, replace = TRUE))
temp <- sapply(temp, paste, collapse = "")
temp <- matrix(temp, nrow = 10, dimnames = list(paste("ind",1:10), paste("loc",1:3)))
## 10 individuals and 3 locuses, random genotype values

## converting to genind
obj_tmp <- df2genind(temp, ploidy = 2, ncode = 2)   # diploid 
obj_tmp <- df2genind(temp, ploidy = 4, sep = "")   # tetraploid

## reverse: converting from genind to df
genind2df(obj_tmp, sep = "|")

############ PA type data ############
## import
df <- read.table(file = system.file("files/AFLP.txt",package = "adegenet"))
objPA <- df2genind(df, ploidy = 1, type = "PA")
tab(objPA)
## generate population id
pop(objPA) <- rep(c('a','b'), 4:3)
## convert to genpop 
popPA <- genind2genpop(objPA)
tab(popPA)
```



## accessing the data

recomended to use accessors -- specific function to get different aspects of data. Their use makes code more robust and safer.

**list of accessors :**

1. nInd: returns the number of individuals in the object; only for genind.
2. nLoc: returns the number of loci.
3. nAll: returns the number of alleles for each locus.
4. nPop: returns the number of populations.
5. tab: returns a table of allele numbers, or frequencies (if requested), with optional, replacement of missing values; replaces the former accessor ’truenames’.
6. indNames † : returns/sets labels for individuals; only for genind.
7. locNames † : returns/sets labels for loci.
8. alleles † : returns/sets alleles.
9. ploidy † : returns/sets ploidy of the individuals; when setting values, a single value can be provided, in which case constant ploidy is assumed.
10. pop † : returns/sets a factor grouping individuals; only for genind.
11. strata † : returns/sets data defining strata of individuals; only for genind.
12. hier † : returns/sets hierarchical groups of individuals; only for genind.
13. other † : returns/sets misc information stored as a list.

```{r}
nInd(obj)
nLoc(obj)
nAll(obj)
nPop(obj)
tab(obj) 
tab(catpop, freq = TRUE)
tab(catpop) %>% dim()
tab(catpop, NA.method = "zero")
indNames(obj) 
locNames(obj)
locNames(obj, withAlleles = TRUE)
locNames(obj)[1] <- "newLocusName"   # can change locus/ind/pop names like this
locNames(obj)
alleles(obj)
ploidy(obj)
pop(obj)
strata(obj)
hier(obj)
other(obj)

```

## SNP data

working with genome wide SNP data, when we have more snp than few thousand, it is better to use genlight object (or SNPbin -- the same as genlight but only for 1 individual) than genind. 
Information represented this way is binary: only biallelic SNPs can be stored
and analyzed using these classes.

Genind objects are designed for codominant markers such as microsatelites.

Genlight objects can incorporate different levels of ploidy across individuals within a single dataset.


```{r}
getClassDef("SNPbin") 
getClassDef("genlight") 

###### SNPbind ########################################
## creating SNPbin objet. Usually only a vector of SNP values and ploidy is needed
sint_snpBin <- new("SNPbin", c(0,1,1,2,0,0,1))
new("SNPbin")   # can also create an empty object

## ploidy can be defined afterwards
ploidy(sint_snpBin) <- 3

## can access original data using function as.integer
as.integer(sint_snpBin)

## comparison of size efficiency
dat <- sample(0:1, 1e6, replace = TRUE)  # 1 million SNP with value 1 and 0
print(object.size(dat), unit = "auto")
x <- new("SNPbin", dat, parallel = FALSE)
x
print(object.size(x), unit = "auto")

identical(as.integer(x), dat)   # data contained in SNPbin is identical to original data even though it takes less space


###### genlight ########################################
# the same as SNPbin but for multiple samples/individuals

new("genlight")   # empty object
sint_genlight <- new("genlight", list(
  indiv1 = c(1, 1, 0, 1, 1, 0), 
  indiv2 = c(2, 1, 1, 0, 0, 0),
  toto = c(2, 2 ,0 ,0 , 4, 4)))

```




```{r}

## creating SNPbind and genlight from true data?
df <- fread(paste0(input, "allSubSpop_chr7_sep_subset1000.geno"), header = FALSE, na.strings = "9")[, -1]   # remove the first chrimp genome

true_snpBin <- new("SNPbin", df$V2, ploidy = 2)

true_genlight <- new("genlight", t(df), ploidy = 2)   # wonder how fast it works for all data, not just 10'000 of SNP

```




